<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Textarium: Bridging Annotation, Abstraction and Argumentation</title>
    <style>
        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-Regular-102a.woff2') format('woff2-variations');
            font-style: normal;
            font-weight: normal;
        }

        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-Italic-102a.woff2') format('woff2-variations');
            font-style: italic;
            font-weight: normal;
        }

        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-Bold-102a.woff2') format('woff2-variations');
            font-style: normal;
            font-weight: bold;
        }

        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-BoldItalic-102a.woff2') format('woff2-variations');
            font-style: italic;
            font-weight: bold;
        }

        html {
            overscroll-behavior: none;
        }

        body {
            font-family: Atkinson, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            font-size: 14pt;
            line-height: 1.3;
            color: #333;
            overflow: hidden;
        }

        .hovered:not(.extracted) {
            background-color: rgba(0, 0, 0, 0.1);
            box-shadow: 0px 0px 5px 4px rgba(0, 0, 0, 0.1);
            padding: 2px 4px;
            margin: -2px -4px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 33ms;
        }

        .extracted {
            transition: all 150ms;
            cursor: url('data:image/x-icon;base64,AAACAAEAICAAAAAAAACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAYAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAABgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAMAAAAFQAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAVAAAADAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAABwAAAAvAAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAAC8AAAAcAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAALAAAAEUAAABMAAAATAAAAEwAAABMAAAATAAAAEwAAABMAAAARQAAACwAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAFMAAABRAAAANQAAABkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/qKio/6ioqP+oqKj/qKio/6ioqP+oqKj/qKio/6ioqP+oqKj/AAAA/wAAAFQAAAA4AAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+oqKj/AAAA/6ioqP8AAAD/qKio/wAAAP+oqKj/AAAA/6ioqP8AAAD/AAAAVQAAADkAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6ioqP8AAAD/qKio/wAAAP+oqKj/AAAA/6ioqP8AAAD/qKio/wAAAP8AAABVAAAAOQAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/qKio/wAAAP+oqKj/AAAA/6ioqP8AAAD/qKio/wAAAP+oqKj/AAAA/wAAAFUAAAA5AAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+oqKj/AAAA/6ioqP8AAAD/qKio/wAAAP+oqKj/AAAA/6ioqP8AAAD/AAAAVQAAADkAAAAdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6ioqP8AAAD/qKio/wAAAP+oqKj/AAAA/6ioqP8AAAD/qKio/wAAAP8AAABVAAAAOwAAAB8AAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/qKio/wAAAP+oqKj/AAAA/6ioqP8AAAD/qKio/wAAAP+oqKj/AAAA/wAAAFUAAABCAAAAJQAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAwAAAP+oqKj/qKio/6ioqP+oqKj/qKio/6ioqP+oqKj/qKio/6ioqP8AAAD/AAAAVAAAAEcAAAAsAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAMAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAABPAAAAQwAAACkAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAP+oqKj/qKio/6ioqP+oqKj/qKio/6ioqP+oqKj/qKio/6ioqP+oqKj/qKio/wAAAP8AAAAuAAAAHAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAAAA/6ioqP+oqKj/qKio/6ioqP+oqKj/qKio/6ioqP+oqKj/qKio/6ioqP+oqKj/AAAA/wAAABUAAAAMAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAABIAAAAiAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAAYAAAABgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAABIAAAAZAAAAEAAAAP8AAAAKAAAAEQAAABcAAAAVAAAAFQAAAP8AAAAXAAAAEQAAAAoAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAAgAAAAFAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAcAAAAFAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA///////////////////////////////////////////////////////////////////////////////////////////wB///4AP//+AD///gA///4AP//+AD///gA///4AP//+AD///gA///wAH//8AB//9gA///O+///xgP//8='), auto;

        }

        #app {
            display: grid;
            grid-template-columns: 50% 50%;
        }

        #text-wrapper {
            z-index: 20;
            padding: 12px 24px;
            overflow-y: scroll;
            height: 100vh;
            scrollbar-width: none;
            overscroll-behavior: none;
        }

        .annotation {
            position: absolute;
            max-width: 300px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 30;
        }

        #connections-wrapper,
        #annotations-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #connections-wrapper {
            pointer-events: none;
            z-index: -1;
        }

        .extracted,
        .annotation,
        .hovered:not(.extracted) {
            border-radius: 3px;
            padding: 1px 4px;
            margin: -1px -4px;
            width: fit-content;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .abstraction-texts {
            font-size: 1.5em;
            line-height: 1.3;
            position: absolute;
            background: none;
            border: none;
            width: fit-content;
        }

        .abstraction-texts:not(.editable) {
            cursor: grab;
        }

        .abstraction-texts.editable {
            cursor: text;
        }

        .ngram {
            padding: 1px 0.15em;
            margin: -1px -0.21em;
        }
    </style>
</head>

<body>
    <script>
        let local = window.location.href.includes('localhost')
    </script>
    <script src="../src/marked.min.js"></script>
    <script src="../src/porter-stemmer.js"></script>
    <script src="../src/convex-hull.js"></script>
    <script src="../src/rangy.min.js"></script>
    <script src="../src/d3.min.js"></script>
    <div id="app">
        <div id="text-wrapper"></div>
        <div id="annotations-wrapper"></div>
        <canvas id="connections-wrapper"></canvas>
    </div>
    <script>
        const TEXTWRAPPER = document.getElementById('text-wrapper');
        const ANNOTATIONSWRAPPER = document.getElementById('annotations-wrapper');
        const CONNECTIONSWRAPPER = document.getElementById('connections-wrapper');
        const CTX = CONNECTIONSWRAPPER.getContext('2d');
        CTX.globalAlpha = 1;
        const COLORS = [
            '#a6cee3',
            '#1f78b4',
            '#b2df8a',
            '#33a02c',
            '#fb9a99',
            '#e31a1c',
            '#fdbf6f',
            '#ff7f00',
            '#cab2d6',
            '#6a3d9a',
            '#ffff99',
            '#b15928',
        ];
        // Application related variables
        let stopLoop = false;
        const SELECTEDTEXT = window.location.hash.slice(1).match(/\w+/)[0];;
        const iFRAME = window.self !== window.top;
        //Animation related variables
        const ANNOTATIONLINEWIDTH = 0.8;
        const ABSTRACTIONSMINIMUMDISTANCE = 50;
        const ABSTRACTIONSMAXIMUMDISTANCE = 350; // Minimum distance between annotations to create an abstraction

        const ANNOTATIONS = [];
        let colorCounter = 0;
        const ABSTRACTIONS = [];
        let dragMovement = false;
        let dragMovementObject = null
        let dragMovementOffsetX = 0;
        let dragMovementOffsetY = 0;


        class Annotation {
            constructor(text, isNgram, sourceElements) {
                this.text = text; // The word or text content of the annotation
                this.id = self.crypto.randomUUID();
                this.sourceElements = sourceElements // The source elements from which the annotation was created
                this.referenceElement = null; // The HTML element representing the annotation
                this.positionX = 0; // X position of the extraction
                this.positionY = 0 // positionY ? positionY : referenceElement.getBoundingClientRect().top; // Y position of the extraction
                this.color = COLORS[(colorCounter++ % COLORS.length)]; // Color based on the text content
                this.abstraction = null;  // List of abstractions this annotation is part of
                this.isClosest = false; // Flag to indicate if the annotation is the closest to the center of the window
                this.isNgram = isNgram // If the annotation represents an ngram, this is true
                this.stems = [];
                if (!this.isNgram) {
                    this.stem = stemmer(text).toLocaleLowerCase(); // The stemmed version of the word
                    this.stems = TEXTWRAPPER.querySelectorAll(`.${this.stem}`); // All stems of the word in the text
                }
                this.initialize();
            }
            deleteAnnotation() {
                // Ensure no race condition with double deletion
                if (ANNOTATIONS.indexOf(this) == -1) return;
                // Remove the annotation from the DOM and the global list
                this.referenceElement.remove();
                ANNOTATIONS.splice(ANNOTATIONS.indexOf(this), 1);
                // Unmark the stems
                TEXTWRAPPER.querySelectorAll(`.annotation-${this.id}`).forEach((element) => {
                    element.classList.remove('annotation-' + this.id);
                    element.classList.remove('extracted');
                    element.style.backgroundColor = '';
                    element.style.color = '';
                });
                // If the annotation is part of an abstraction, remove it from the abstraction
                if (this.abstraction) {
                    this.abstraction.removeElement(this);
                }
                // Encode the state as a URL hash
                setURLHashState();
                delete this;
            }
            initialize() {
                this.sourceElements.map(element => {
                    element.classList.add('extracted');
                    element.classList.add(`annotation-${this.id}`);
                    if (this.isNgram) {
                        element.classList.add('ngram');
                    }
                    element.style.backgroundColor = this.color;
                    element.style.color = whiteOrBlackText(this.color);
                    window.setTimeout(() => {
                        element.addEventListener('click', (e) => {
                            if (iFRAME) return;
                            e.preventDefault();
                            e.stopPropagation();
                            this.deleteAnnotation();
                        })
                    }, 300);
                })
                let referenceElement = document.createElement('div');
                referenceElement.className = 'annotation';
                referenceElement.style.backgroundColor = this.color;
                referenceElement.style.color = whiteOrBlackText(this.color);
                referenceElement.innerText = this.text;
                ANNOTATIONSWRAPPER.appendChild(referenceElement);
                this.referenceElement = referenceElement;
                this.referenceElement.addEventListener('mousedown', (e) => setDragMovement(e, this));
                this.updatePosition(window.innerWidth / 1.5, this.referenceElement.getBoundingClientRect().top);
                if (this.isNgram) {
                    const firstWord = this.text.split(' ')[0];
                    const ngramWords = this.text.split(' ');
                    const ngramLength = ngramWords.length;
                    // Find all elements with the first word of the ngram
                    const allFirstWordElements = Array.from(TEXTWRAPPER.querySelectorAll(`.word.${stemmer(firstWord).toLocaleLowerCase()}`));
                    allFirstWordElements.forEach((el) => {
                        let match = true;
                        let ngramElements = [el];
                        let next = el;
                        for (let i = 1; i < ngramLength; i++) {
                            next = next.nextElementSibling;
                            if (!next || !next.classList.contains('word')) {
                                match = false;
                                break;
                            }
                            const nextStem = stemmer(ngramWords[i]).toLocaleLowerCase();
                            if (!next.classList.contains(nextStem)) {
                                match = false;
                                break;
                            }
                            ngramElements.push(next);
                        }
                        if (match) {
                            this.stems.push(ngramElements[ngramElements.length - 1]);
                            ngramElements.forEach((ngEl) => {
                                ngEl.classList.add('extracted', 'ngram');
                                ngEl.classList.add(`annotation-${this.id}`);
                                ngEl.style.backgroundColor = this.color;
                                ngEl.style.color = whiteOrBlackText(this.color);
                                window.setTimeout(() => {
                                    ngEl.addEventListener('click', (e) => {
                                        if (iFRAME) return;
                                        e.preventDefault();
                                        e.stopPropagation();
                                        this.deleteAnnotation();
                                    })
                                }, 300);
                            });
                        }
                    });
                }
                this.stems.forEach((stemInstance) => {
                    stemInstance.classList.add('extracted');
                    stemInstance.style.backgroundColor = this.color;
                    stemInstance.style.color = whiteOrBlackText(this.color);
                    window.setTimeout(() => {
                        stemInstance.addEventListener('click', (e) => {
                            if (iFRAME) return;
                            e.preventDefault();
                            e.stopPropagation();
                            this.deleteAnnotation();
                        })
                    }, 300)
                });
                ANNOTATIONS.push(this);
                setURLHashState();
            }
            updatePosition(x, y, updateAbstraction = true) {
                this.positionX = x;
                this.positionY = y;
                this.referenceElement.style.left = `${this.positionX}px`;
                this.referenceElement.style.top = `${this.positionY}px`;
                if (this.abstraction != null && updateAbstraction) {
                    this.abstraction.updateTextElementPosition();
                }
                this.checkAbstractions();
            }
            checkAbstractions() {
                //Check distance to all other annotations 
                ANNOTATIONS.forEach((annotation) => {
                    if (annotation !== this) {
                        let distance = Math.sqrt(
                            Math.pow(this.positionX - annotation.positionX, 2) +
                            Math.pow(this.positionY - annotation.positionY, 2)
                        );
                        if (distance < ABSTRACTIONSMINIMUMDISTANCE) {
                            // Check if there is already an abstraction with this annotation
                            if (this.abstraction != null && this.abstraction.annotations.find(a => a === annotation)) return
                            // If there is no existing abstraction, check if the annotation has an abstraction already
                            // which the current element can join 
                            if (annotation.abstraction != null) {
                                // Create a new abstraction
                                this.abstraction = annotation.abstraction;
                                this.abstraction.addElement(this);
                            } else if (this.abstraction == null && annotation.abstraction == null) {
                                // Create a new abstraction
                                let newAbstraction = new Abstraction();
                                this.abstraction = newAbstraction;
                                annotation.abstraction = newAbstraction;
                                newAbstraction.addElement(this);
                                newAbstraction.addElement(annotation);
                            }
                            setURLHashState();
                        }
                    }
                });
            }
            renderConnections() {
                let referenceElementBB = this.referenceElement.getBoundingClientRect();
                if (!referenceElementBB) return;
                let positionX = referenceElementBB.left + referenceElementBB.width / 2;
                let positionY = referenceElementBB.top + referenceElementBB.height / 2;
                // Render the connections to the stems
                this.stems.forEach((stem) => {
                    let stemBB = stem.getBoundingClientRect();
                    let stemX = stemBB.left + stemBB.width / 2;
                    let stemY = stemBB.top + stemBB.height / 2;
                    CTX.beginPath();
                    CTX.moveTo(positionX, positionY);
                    CTX.lineTo(stemX, stemY);
                    let verticalDistance = Math.abs(stemY - positionY);
                    let opacity = Math.max(0.3, Math.pow((TEXTWRAPPER.scrollHeight - verticalDistance) / TEXTWRAPPER.scrollHeight, 10));
                    let hexOpacity = Math.round(opacity * 255).toString(16).padStart(2, '0');
                    CTX.strokeStyle = `${this.color}${hexOpacity}`;
                    CTX.lineWidth = ANNOTATIONLINEWIDTH + 3 * opacity;
                    CTX.stroke();
                });
            }
            getAsURLHash() {
                // Encode the annotation as a string for the URL hash
                return `${this.isClosest ? '!' : ''}` +
                `${this.sourceElements[0].id}${this.isNgram ? `_${this.text.split(' ').length > 2?'tri':'bi'}gram`: ''}` +
                `(${(this.positionX / window.innerWidth).toFixed(2)},${(this.positionY / window.innerHeight).toFixed(2)})`;
            }
        }
        class Abstraction {
            constructor(text = "Abstraction") {
                this.annotations = [];
                this.id = self.crypto.randomUUID();
                this.referenceElement = null
                this.text = text; // The text content of the abstraction
                this.initialize();
            }
            initialize() {
                let abstractionTextElement = document.createElement("input");
                abstractionTextElement.contentEditable = false;
                abstractionTextElement.type = "text";
                abstractionTextElement.classList.add("abstraction-texts");
                abstractionTextElement.value = this.text;
                abstractionTextElement.style.width = this.text.length + "ch";
                abstractionTextElement.addEventListener('input', (e) => {
                    this.text = e.target.value;
                    abstractionTextElement.style.width = this.text.length + "ch";
                    this.updateTextElementPosition();
                    setURLHashState();
                });
                abstractionTextElement.addEventListener('mousedown', (e) => setDragMovement(e, this));
                abstractionTextElement.addEventListener("dblclick", (e) => {
                    if (iFRAME) return;
                    abstractionTextElement.contentEditable = true;
                    abstractionTextElement.classList.add("editable");
                    abstractionTextElement.focus();
                    abstractionTextElement.select();
                });
                abstractionTextElement.addEventListener("focus", (e) => {
                    console.log("focus")
                });
                abstractionTextElement.addEventListener("blur", (e) => {
                    console.log("blur")
                    abstractionTextElement.contentEditable = false;
                    abstractionTextElement.classList.remove("editable");
                });
                this.referenceElement = abstractionTextElement;
                document.body.appendChild(abstractionTextElement);
                ABSTRACTIONS.push(this);
            }
            addElement(annotation) {
                this.annotations.push(annotation);
            }
            removeElement(annotation) {
                this.annotations.splice(this.annotations.indexOf(annotation), 1);
            }
            updatePosition(x, y) {
                if (!this.referenceElement) return;
                // Move all annotations relative to the abstraction's previous position
                const prevX = parseFloat(this.referenceElement.style.left) || 0;
                const prevY = parseFloat(this.referenceElement.style.top) || 0;
                const deltaX = x - prevX;
                const deltaY = y - prevY;
                this.referenceElement.style.left = `${x}px`;
                this.referenceElement.style.top = `${y}px`;
                this.annotations.forEach((annotation) => {
                    annotation.updatePosition(annotation.positionX + deltaX, annotation.positionY + deltaY, false);
                });
                this.renderHull();
            }
            updateTextElementPosition() {
                if (!this.referenceElement) return;
                // Position the text element at the center of all annotations
                this.text = this.referenceElement.value;
                let boundingBox = this.annotations.reduce((acc, annotation) => {
                    let element = annotation.referenceElement.getBoundingClientRect();
                    acc.left = Math.min(acc.left, element.left);
                    acc.top = Math.min(acc.top, element.top);
                    acc.right = Math.max(acc.right, element.left + element.width);
                    acc.bottom = Math.max(acc.bottom, element.top + element.height);
                    return acc;
                }, { left: Infinity, top: Infinity, right: -Infinity, bottom: -Infinity })
                let centerX = (boundingBox.left + boundingBox.right) / 2;
                let centerY = (boundingBox.top + boundingBox.bottom) / 2;
                this.referenceElement.style.left = `${centerX - this.referenceElement.offsetWidth / 2}px`;
                this.referenceElement.style.top = `${centerY}px`;
            }
            renderHull() {
                if (!this.checkAnnotations()) return;
                // Render the hull of the abstraction
                if (this.annotations.length < 2) {
                    console.log("removing abstraction")
                    this.annotations.forEach((annotation) => {
                        // Remove the annotation from the abstraction
                        annotation.abstraction = null;
                        this.removeElement(annotation);
                    });
                    // Remove the abstraction from the global list
                    ABSTRACTIONS.splice(ABSTRACTIONS.indexOf(this), 1);
                    return;
                }
                let coordinates = this.annotations.map((annotation) => {
                    let element = annotation.referenceElement.getBoundingClientRect();
                    // return all points of the bounding rect as a two-dimensional array
                    return [
                        [element.left, element.top],
                        [element.left + element.width, element.top],
                        [element.left + element.width, element.top + element.height],
                        [element.left, element.top + element.height],
                    ];
                }).flat();
                let hull = monotoneChainConvexHull(coordinates);
                if (hull.length < 3) return;
                // Draw the hull
                CTX.beginPath();
                CTX.moveTo(hull[0][0], hull[0][1]);
                hull.forEach((point) => {
                    CTX.lineTo(point[0], point[1]);
                });
                CTX.closePath();
                CTX.fillStyle = this.annotations[0].color + "90";
                CTX.fill();
            }
            checkAnnotations() {
                // Check if the distance of every annotation is at least ABSTRACTIONSMAXIMUMDISTANCE to one of the others
                // if not, remove the annotation from the abstraction
                for (let x = 0; x < this.annotations.length; x++) {
                    let oneCloseAnnotation = false;
                    for (let y = 0; y < this.annotations.length; y++) {
                        if (x == y) continue;
                        let annotation1 = this.annotations[x];
                        let annotation2 = this.annotations[y];
                        // Check if the distance between the two annotations is below the minimum distance
                        let distance = Math.sqrt(
                            Math.pow(annotation1.positionX - annotation2.positionX, 2) +
                            Math.pow(annotation1.positionY - annotation2.positionY, 2)
                        );
                        if (distance < ABSTRACTIONSMAXIMUMDISTANCE) {
                            oneCloseAnnotation = true;
                        }
                    }
                    if (!oneCloseAnnotation) {
                        // If we reach this point, it means the annotation is too far from all others
                        this.annotations[x].abstraction = null;
                        // Remove the annotation from the abstraction
                        this.removeElement(this.annotations[x]);
                        this.updateTextElementPosition();
                        setURLHashState();
                    }
                }
                if (this.annotations.length < 2) {
                    this.annotations.forEach((annotation) => {
                        // Remove the abstraction from the annotation
                        annotation.abstraction = null;
                    });
                    // Remove the abstraction from the global list
                    ABSTRACTIONS.splice(ABSTRACTIONS.indexOf(this), 1);
                    this.referenceElement.remove();
                    this.referenceElement = null;
                    setURLHashState();
                    delete this;
                    return false;
                }
                return true;
            }
            getAsURLHash() {
                // Encode the abstraction as a string for the URL hash
                return `${this.text.replaceAll(' ', '_')}(${this.annotations.map((annotation) => annotation.getAsURLHash()).join(',')})`;
            }
        }
        function setConnectionsWrapperSize() {
            CONNECTIONSWRAPPER.width = window.innerWidth;
            CONNECTIONSWRAPPER.height = window.innerHeight;
        }
        function getNWordElementSiblingsAhead(element, n){
            // Get n-amount of .word element siblings ahead of the current element with the same class
            let siblings = [element];
            let currentElement = element;
            let i = 0
            console.log('Finding siblings for', element, 'with n =', n);
            while (currentElement != null && siblings.length < n) {
                if (i++ > 30) {
                    console.log('Stopping to find siblings, too many iterations');
                    break;
                }
                if (currentElement.nodeType == Node.TEXT_NODE && currentElement.parentElement.classList.contains('word')) {
                    currentElement = currentElement.parentElement;
                }
                currentElement = currentElement.nextElementSibling;
                if (currentElement.classList.contains('word')) {
                    siblings.push(currentElement);
                }
            }
            console.log('Found siblings:', siblings);
            return siblings;
        }
        function getWordElementSiblingsAhead(element, endElement) {
            // Get n-amount of .word element siblings ahead of the current element with the same class
            let siblings = [element];
            let currentElement = element;
            let i = 0
            console.log('Finding siblings for', element, 'with endElement =', endElement);
            while (currentElement !== endElement && currentElement != null) {
                if (i++ > 30) {
                    console.log('Stopping to find siblings, too many iterations');
                    break;
                }
                if (currentElement.nodeType == Node.TEXT_NODE && currentElement.parentElement.classList.contains('word')) {
                    currentElement = currentElement.parentElement;
                }
                currentElement = currentElement.nextElementSibling;
                if (currentElement.classList.contains('word')) {
                    siblings.push(currentElement);
                }
            }
            console.log('Found siblings:', siblings);
            return siblings;

        }
        function whiteOrBlackText(color) {
            // Function to determine the text color based on the background color based on brightness -> https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
            let r = parseInt(color.slice(1, 3), 16);
            let g = parseInt(color.slice(3, 5), 16);
            let b = parseInt(color.slice(5, 7), 16);
            // Calculate brightness
            let brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#ffffff'; // Return black or white based on brightness
        }
        function setDragMovement(e, dragElement) {
            if (iFRAME) return;
            e.preventDefault();
            dragMovement = true;
            dragMovementObject = dragElement;
            dragMovementObject.referenceElement.style.cursor = 'grabbing';
            let boundingClient = dragElement.referenceElement.getBoundingClientRect();
            console.log('Setting drag movement', boundingClient);
            dragMovementOffsetX = e.clientX - boundingClient.left
            if (!dragMovementObject.annotations) {
                dragMovementOffsetX -= boundingClient.width / 2;
            }
            dragMovementOffsetY = e.clientY - (boundingClient.top + boundingClient.height / 2);
        }
        function setURLHashState() {
            if (resetPage) return;
            console.log('Setting URL hash');
            // Set the URL hash to the current annotations
            let annotationHash = ANNOTATIONS.map((annotation) => {
                if (annotation.abstraction) return null;
                return annotation.getAsURLHash();
            }).filter((item) => item !== null)
            let abstractionHash = ABSTRACTIONS.map((abstraction) => {
                return abstraction.getAsURLHash();
            })
            let joinedHash = [...abstractionHash, ...annotationHash].join(';');
            window.location.hash = `${SELECTEDTEXT}&annotations=${joinedHash}`;
        }
        function getURLHashState() {
            resetPage = true;
            // Reset the state from the URL hash
            let hash = decodeURI(window.location.hash.slice(1));
            if (hash) {
                let annotationsString = window.location.hash.match(/annotations.*/g);
                if(annotationsString){
                    annotationsString = annotationsString[0].slice(12); // remove the 'annotations=' part
                    annotationsArray = annotationsString.split(';');
                    let annotationsToCreate = [];
                    annotationsArray.map((annotation,annotationIndex) => {
                        let annotationParts = annotation.match(/(\w+)(\w+)/g);
                        if (!annotationParts) {
                            console.warn('No valid annotation parts found in', annotation);
                            return;
                        }
                        console.log('Annotation parts', annotationParts);
                        if(RegExp(/\([!a-zA-Z]/g).test(annotation)){
                            let abstractionName = annotationParts[0].replaceAll('_', ' ');
                            let newAbstraction = new Abstraction(abstractionName);
                            annotationParts = annotationParts.slice(1);
                            for (let i = 0; i < annotationParts.length; i += 3) {
                                annotationsToCreate.push([annotationParts[i], annotationParts[i + 1], annotationParts[i + 2], newAbstraction]);
                            }
                        }else{
                           annotationsToCreate.push([annotationParts[0], annotationParts[1], annotationParts[2],null]);
                        }
                    })
                    annotationsToCreate.map((annotation) => {
                        console.log('Creating annotation from URL hash', annotation);
                        let annotationInstance = null;
                        if(annotation[0].includes('_bigram')){
                            annotation[0] = annotation[0].replace('_bigram', '');
                            // If the annotation is a bigram, get all word elements ahead of the reference element
                            let ngramElements = getNWordElementSiblingsAhead(TEXTWRAPPER.querySelector('#' + annotation[0]), 2);
                            annotationInstance = new Annotation(ngramElements.map(el => el.innerText).join(' '), true, ngramElements);
                        }else if(annotation[0].includes('_trigram')){
                            annotation[0] = annotation[0].replace('_trigram', '');
                            // If the annotation is a trigram, get all word elements ahead of the reference element
                            let ngramElements = getNWordElementSiblingsAhead(TEXTWRAPPER.querySelector('#' + annotation[0]), 3);
                            annotationInstance = new Annotation(ngramElements.map(el => el.innerText).join(' '), true, ngramElements);
                        }else{
                            let element = TEXTWRAPPER.querySelector('#' + annotation[0]);
                            annotationInstance = new Annotation(element.innerText, false, [element]);
                        }
                        if(annotation[3]){
                            annotationInstance.abstraction = annotation[3]
                            annotation[3].addElement(annotationInstance);
                        }
                        annotationInstance.updatePosition(parseFloat(annotation[1]/100) * window.innerWidth, parseFloat(annotation[2]/100) * window.innerHeight);
                    });
                }
            }
            console.log('Annotations and Abstractions loaded from URL hash', ANNOTATIONS, ABSTRACTIONS);
            resetPage = false;
        }
        function resetState() {
            stopLoop = true;
            // Remove all annotations and abstractions from the DOM
            ANNOTATIONS.forEach((annotation) => {
                annotation.deleteAnnotation();
            });
            ABSTRACTIONS.forEach((abstraction) => {
                abstraction.deleteAbstraction();
            });
            // Reset all global variables
            ANNOTATIONS.splice(0, ANNOTATIONS.length);
            ABSTRACTIONS.splice(0, ABSTRACTIONS.length);
            colorCounter = 0;
            stopLoop = false;
            dragMovement = false;
        }
        window.addEventListener('mousemove', (e) => {
            if (dragMovement && !iFRAME) {
                let newLeft = e.clientX - dragMovementOffsetX;
                let newTop = e.clientY - dragMovementOffsetY;
                dragMovementObject.updatePosition(newLeft, newTop);
            }
        });
        window.addEventListener('mouseup', (e) => {
            if (dragMovement && !iFRAME) {
                dragMovement = false;
                dragMovementObject.referenceElement.style.cursor = 'grab';
                dragMovementObject = null;
                setURLHashState();
            } else {
                let selection = window.getSelection();
                if (selection.toString().trim() !== '') {
                    const range = selection.getRangeAt(0);
                    const selectedText = selection.toString();
                    const findStartOfFirstWord = (range) => {
                        let start = range.startOffset;
                        const startContainerText = range.startContainer.textContent;
                        while (start > 0 && !/\s/.test(startContainerText[start - 1])) {
                            start--;
                        }
                        return start;
                    };
                    // Function to find the end of the last whole word
                    const findEndOfLastWord = (range) => {
                        let end = range.endOffset;
                        const endContainerText = range.endContainer.textContent;
                        while (end < endContainerText.length && !/\s/.test(endContainerText[end])) {
                            end++;
                        }
                        return end;
                    };
                    // Adjust the range to include whole words
                    range.setStart(range.startContainer, findStartOfFirstWord(range));
                    range.setEnd(range.endContainer, findEndOfLastWord(range));

                    // Clear the current selection and apply the new range
                    selection.removeAllRanges();
                    selection.addRange(range);
                    console.log('Selected text:', selection);
                    // Get all word spans in this selection
                    if (selection.anchorNode.nodeType == Node.TEXT_NODE && selection.anchorNode == selection.focusNode) {
                        new Annotation(selection.toString(), false, [selection.anchorNode.parentElement]);
                    } else {
                        let allNodes = getWordElementSiblingsAhead(selection.anchorNode.parentElement, selection.focusNode.parentElement)
                        if (allNodes.length < 4) {// ensure max trigrams
                            console.log('Creating annotation for selection:', selection.toString(), allNodes);
                            new Annotation(selection.toString(), true, allNodes);
                        }
                    }
                    selection.removeAllRanges(); // Clear the selection after creating the annotation
                }
            }
        });
        window.addEventListener('resize', (e) => {
            setConnectionsWrapperSize();
        });
        window.addEventListener('hashchange', (e) => {
            if (!iFRAME) return;
            resetState();
            getURLHashState();
            loop();
        });
        TEXTWRAPPER.addEventListener('scroll', (e) => {
            let centerY = TEXTWRAPPER.scrollTop + window.innerHeight / 2;
            let closest = null;
            let minDistance = Infinity;
            ANNOTATIONS.forEach(annotation => {
                annotation.isClosest = false; // Reset the closest flag for all annotations
                let refEl = TEXTWRAPPER.querySelector('#' + annotation.sourceElements[0].id);
                if (refEl) {
                    console.log('Checking annotation:', annotation);
                    let rect = refEl.getBoundingClientRect();
                    let elCenterY = rect.top + TEXTWRAPPER.scrollTop + rect.height / 2;
                    let distance = Math.abs(elCenterY - centerY);
                    console.log('Distance to center:', distance);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = annotation
                    }
                }
            });
            if(closest) {
                closest.isClosest = true; 
            }
        })
        async function loop() {
            if (stopLoop) return
            // Clear the canvas and redraw all connections and hull
            CTX.clearRect(0, 0, CONNECTIONSWRAPPER.width, CONNECTIONSWRAPPER.height);
            ANNOTATIONS.forEach((annotation) => {
                annotation.renderConnections();
            });
            ABSTRACTIONS.forEach((abstraction) => {
                abstraction.renderHull();
            });
            requestAnimationFrame(loop);
        }
        fetch(`/${local ? '' : 'textarium/'}${SELECTEDTEXT}.md`)
            .then(response => response.text())
            .then(text => {
                if (!text) {
                    console.error('No text found for the given hash:', SELECTEDTEXT);
                    return;
                }

                let parsedText = text
                    .replaceAll('\n', ' \n ')
                    .split(' ')
                
                parsedText = parsedText
                    .map((word, index) => {
                        if (word != '#' && !RegExp(/[<>\d|]/).test(word)) {
                            console.log('Processing word:', word.length);

                            let sanitizedWord = word.replace(/[^a-zA-Z-]/g, '');
                            let stemmedWord = stemmer(sanitizedWord).toLocaleLowerCase();
                            if(sanitizedWord.length == 1) {
                                return  `<span id="${sanitizedWord + index}" class='word ${stemmedWord}'>${word}</span>`; // Skip single character words
                            }else{
                                return word.replace(
                                    /(\w+-?\w+)/g,
                                    //`<span id="${sanitizedWord + index}" onclick="Annotation.createAnnotation('${sanitizedWord}', '${sanitizedWord + index}')" onmouseleave="hideRelatedWordStems()" onmouseenter="showRelatedWordStems('${stemmedWord}')" class='word ${stemmedWord}'>${sanitizedWord}</span>`
                                    `<span id="${sanitizedWord + index}" class='word ${stemmedWord}'>$1</span>`
                                );
                            }
                        }
                        return word;
                    })
                    .join(' ');
                TEXTWRAPPER.innerHTML = marked.parse(parsedText);
            }).then(() => {
                getURLHashState();
                setConnectionsWrapperSize();
                loop();
            })
    </script>
</body>

</html>