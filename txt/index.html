<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Textarium: Bridging Annotation, Abstraction and Argumentation</title>
    <style>
        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-Regular-102a.woff2') format('woff2-variations');
            font-style: normal;
            font-weight: normal;
        }

        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-Italic-102a.woff2') format('woff2-variations');
            font-style: italic;
            font-weight: normal;
        }

        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-Bold-102a.woff2') format('woff2-variations');
            font-style: normal;
            font-weight: bold;
        }

        @font-face {
            font-family: 'Atkinson';
            src: url('include/fonts/Atkinson-Hyperlegible-BoldItalic-102a.woff2') format('woff2-variations');
            font-style: italic;
            font-weight: bold;
        }

        html {
            overscroll-behavior: none;
        }

        body {
            font-family: Atkinson, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            font-size: 14pt;
            line-height: 1.3;
            color: #333;
            overflow: hidden;
        }

        .hovered:not(.extracted){
            text-decoration: dotted underline;
            cursor: pointer;
            transition: all 50ms;
        }

        .extracted {
            transition: all 150ms;
            pointer-events: none;
            cursor: help;
        }

        #app {
            display: grid;
            grid-template-columns: 35% 35% 30%;
        }

        #text-wrapper {
            width: 500px;
            z-index: 20;
            padding: 16px 48px;
            overflow-y: scroll;
            height: 100vh;
            scrollbar-width: none;
            overscroll-behavior: none;
        }

        #annotations-wrapper {
            height: 100vh;
            width: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }

        .annotation {
            position: absolute;
            max-width: 300px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 10;
        }

        #connections-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .extracted,
        .annotation,
        .hovered:not(.extracted) {
            border-radius: 3px;
            padding: 1px 4px;
            margin: -1px -4px
        }

        .abstraction-texts {
            font-size: 1.5em;
            line-height: 1.3;
            font-family: Atkinson, sans-serif;
            position: absolute;
            background: none;
            border: none;
            width: fit-content;
        }
    </style>
</head>

<body>
    <script>
        let local = window.location.href.includes('localhost')
    </script>
    <script src="../src/marked.min.js"></script>
    <script src="../src/porter-stemmer.js"></script>
    <script src="../src/convex-hull.js"></script>
    <script src="../src/rangy.min.js"></script>
    <script src="../src/d3.min.js"></script>
    <div id="app">
        <div id="text-wrapper"></div>
        <div id="annotations-wrapper"></div>
        <canvas id="connections-wrapper"></canvas>
    </div>
    <script>
        // GLOBAL VARIABLES
        const TEXTWRAPPER = document.getElementById('text-wrapper');
        const ANNOTATIONSWRAPPER = document.getElementById('annotations-wrapper');
        const CONNECTIONSWRAPPER = document.getElementById('connections-wrapper');
        const CTX = CONNECTIONSWRAPPER.getContext('2d');
        const COLORS = [
            '#a6cee3',
            '#1f78b4',
            '#b2df8a',
            '#33a02c',
            '#fb9a99',
            '#e31a1c',
            '#fdbf6f',
            '#ff7f00',
            '#cab2d6',
            '#6a3d9a',
            '#ffff99',
            '#b15928',
        ];
        // Application related variables
        let textHash = '';
        let blockHashChangeEvent = false;
        let stopLoop = false;
        const iFRAME = window.self !== window.top;
        //Animation related variables
        let annotationLineOpacity = 0.3;
        const ANNOTATIONLINEWIDTH = 0.8;
        const ABSTRACTIONSMINIMUMDISTANCE = 50;
        const ABSTRACTIONSMAXIMUMDISTANCE = 350; // Minimum distance between annotations to create an abstraction

        // Annotation-related variables
        let ANNOTATIONS = [];
        let ABSTRACTIONS = [];
        let colorCounter = 0;
        let annotationsMovement = false;
        let annotationsMovementObject = null
        let annotationsMovementOffsetX = 0;
        let annotationsMovementOffsetY = 0;

        class Annotation {
            constructor(text, reference = null, positionX = window.innerWidth / 1.5, positionY = null) {
                this.text = text; // The word or text content of the annotation
                this.stem = stemmer(text).toLocaleLowerCase(); // The stemmed version of the word
                this.element = null;
                this.reference = reference; // ID for the extraction element
                this.positionX = positionX; // X position of the extraction
                let referenceElement = TEXTWRAPPER.querySelector('#' + reference);
                this.positionY = positionY ? positionY : referenceElement.getBoundingClientRect().top; // Y position of the extraction
                this.color = COLORS[(colorCounter++ % COLORS.length)]; // Color based on the text content
                this.textColor = this.getColor(this.color); // Default text color
                this.stems = TEXTWRAPPER.querySelectorAll(`.${this.stem}`); // All stems of the word in the text
                this.abstraction = null;
                this.firstPaint();
            }
            static createAnnotation(word, reference) {
                return new Annotation(word, reference);
            }
            getColor(color) {
                // Function to determine the text color based on the background color based on brightness -> https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
                let r = parseInt(color.slice(1, 3), 16);
                let g = parseInt(color.slice(3, 5), 16);
                let b = parseInt(color.slice(5, 7), 16);
                // Calculate brightness
                let brightness = (r * 299 + g * 587 + b * 114) / 1000;
                return brightness > 128 ? '#000000' : '#ffffff'; // Return black or white based on brightness
            }
            firstPaint() {
                let annotationElement = document.createElement('div');
                annotationElement.className = 'annotation';
                annotationElement.style.backgroundColor = this.color;
                annotationElement.style.color = this.textColor;
                annotationElement.innerText = this.text;
                ANNOTATIONSWRAPPER.appendChild(annotationElement);
                this.element = annotationElement;
                annotationElement.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    let boundingClient = annotationElement.getBoundingClientRect();
                    annotationElement.style.cursor = 'grabbing';
                    annotationsMovement = true;
                    annotationsMovementObject = this;
                    annotationsMovementOffsetX = e.clientX - (boundingClient.left + boundingClient.width / 2);
                    annotationsMovementOffsetY = e.clientY - (boundingClient.top + boundingClient.height / 2);
                });
                this.updatePosition(this.positionX, this.positionY);
                this.stems.forEach((stemInstance) => {
                    stemInstance.classList.add('extracted');
                    stemInstance.style.backgroundColor = this.color;
                    stemInstance.style.color = this.textColor;
                });
                ANNOTATIONS.push(this);
                encodeStateAsURLHash();
            }
            updatePosition(x, y) {
                this.positionX = x;
                this.positionY = y;
                if (this.element) {
                    this.element.style.left = `${x}px`;
                    this.element.style.top = `${y}px`;
                }
                if (this.abstraction) {
                    this.abstraction.updateTextElementPosition();
                }
                this.checkAbstractions();
            }
            checkAbstractions() {
                // Check distance to all other annotations 
                ANNOTATIONS.forEach((annotation) => {
                    if (annotation !== this) {
                        let distance = Math.sqrt(
                            Math.pow(this.positionX - annotation.positionX, 2) +
                            Math.pow(this.positionY - annotation.positionY, 2)
                        );
                        if (distance < ABSTRACTIONSMINIMUMDISTANCE) {
                            // Check if there is already an abstraction with this annotation
                            if (this.abstraction != null && this.abstraction == annotation.abstraction) return
                            // If there is no existing abstraction, check if the annotation has an abstraction already
                            // which the current element can join 
                            if (annotation.abstraction != null) {
                                // Create a new abstraction
                                this.abstraction = annotation.abstraction;
                                this.abstraction.addElement(this);
                            } else if (this.abstraction == null && annotation.abstraction == null) {
                                // Create a new abstraction
                                let newAbstraction = new Abstraction();
                                this.abstraction = newAbstraction;
                                annotation.abstraction = newAbstraction;
                                newAbstraction.addElement(this);
                                newAbstraction.addElement(annotation);
                                ABSTRACTIONS.push(newAbstraction);
                            }
                            encodeStateAsURLHash();
                        }
                    }
                });
            }
            renderConnections() {
                let referenceElementBoundingBox = this.element.getBoundingClientRect();
                if (!referenceElementBoundingBox) return;
                let positionX = referenceElementBoundingBox.left + referenceElementBoundingBox.width / 2;
                let positionY = referenceElementBoundingBox.top + referenceElementBoundingBox.height / 2;
                // Render the connections to the stems
                this.stems.forEach((stemInstance) => {
                    let stemInstanceBoundingBox = stemInstance.getBoundingClientRect();
                    let stemInstanceX = stemInstanceBoundingBox.left + stemInstanceBoundingBox.width / 2;
                    let stemInstanceY = stemInstanceBoundingBox.top + stemInstanceBoundingBox.height / 2;
                    CTX.beginPath();
                    CTX.moveTo(positionX, positionY);
                    CTX.lineTo(stemInstanceX, stemInstanceY);
                    let verticalDistance = Math.abs(stemInstanceY);
                    let opacity = Math.max(0.2, Math.pow((TEXTWRAPPER.scrollHeight - verticalDistance)/TEXTWRAPPER.scrollHeight, 6));
                    let hexOpacity = Math.round(opacity * 255).toString(16).padStart(2, '0');
                    CTX.strokeStyle = this.color + hexOpacity;
                    CTX.lineWidth = ANNOTATIONLINEWIDTH + 2 * opacity;
                    CTX.closePath();
                    CTX.stroke();

                });
            }
            encodeAsURLHash() {
                // Encode the annotation as a string for the URL hash
                return `${this.reference}(${Math.round(this.positionX)},${Math.round(this.positionY)})`;
            }
        }
        class Abstraction {
            constructor(text = "Abstraction") {
                this.annotations = [];
                this.id = self.crypto.randomUUID();
                this.element = null
                this.text = text; // The text content of the abstraction
                this.firstPaint();
            }
            firstPaint() {
                let abstractionTextElement = document.createElement("span");
                abstractionTextElement.contentEditable = iFRAME? false: true;
                abstractionTextElement.type = "text";
                abstractionTextElement.classList.add("abstraction-texts");
                abstractionTextElement.innerText = this.text;
                abstractionTextElement.addEventListener("focus", (e) => {
                    console.log("focus")
                    stopLoop = true;
                });
                abstractionTextElement.addEventListener("blur", (e) => {
                    console.log("blur")
                    this.updateTextElementPosition();
                    encodeStateAsURLHash();
                    stopLoop = false;
                    loop();
                });
                this.element = abstractionTextElement;
                document.body.appendChild(abstractionTextElement);
            }
            addElement(annotation) {
                this.annotations.push(annotation);
            }
            removeElement(annotation) {
                this.annotations = this.annotations.filter((el) => el !== annotation);
            }
            updateTextElementPosition() {
                if (!this.element) return;
                // Position the text element at the center of all annotations
                this.text = this.element.innerText;
                let boundingBox = this.annotations.reduce((acc, annotation) => {
                    let element = annotation.element.getBoundingClientRect();
                    acc.left = Math.min(acc.left, element.left);
                    acc.top = Math.min(acc.top, element.top);
                    acc.right = Math.max(acc.right, element.left + element.width);
                    acc.bottom = Math.max(acc.bottom, element.top + element.height);
                    return acc;
                }, { left: Infinity, top: Infinity, right: -Infinity, bottom: -Infinity })
                let centerX = (boundingBox.left + boundingBox.right) / 2;
                let centerY = (boundingBox.top + boundingBox.bottom) / 2;
                this.element.style.left = `${centerX - this.element.offsetWidth / (this.annotations.length > 2 ? 3 : 2)}px`;
                this.element.style.top = `${centerY - this.element.offsetHeight / (this.annotations.length > 2 ? 3 : 2)}px`;
            }
            renderHull() {
                if (!this.checkAnnotations()) return;
                // Render the hull of the abstraction
                if (this.annotations.length < 2) {
                    console.log("removing abstraction")
                    this.annotations.forEach((annotation) => {
                        // Remove the annotation from the abstraction
                        annotation.abstraction = null;
                        this.removeElement(annotation);
                    });
                    // Remove the abstraction from the global list
                    ABSTRACTIONS.splice(ABSTRACTIONS.indexOf(this), 1);
                    return;
                }
                let coordinates = this.annotations.map((annotation) => {
                    let element = annotation.element.getBoundingClientRect();
                    // return all points of the bounding rect as a two-dimensional array
                    return [
                        [element.left, element.top],
                        [element.left + element.width, element.top],
                        [element.left + element.width, element.top + element.height],
                        [element.left, element.top + element.height],
                    ];
                }).flat();
                let hull = monotoneChainConvexHull(coordinates);
                if (hull.length < 3) return;
                // Draw the hull
                CTX.beginPath();
                CTX.moveTo(hull[0][0], hull[0][1]);
                hull.forEach((point) => {
                    CTX.lineTo(point[0], point[1]);
                });
                CTX.closePath();
                CTX.globalAlpha = 0.3;
                CTX.fillStyle = this.annotations[0].color;
                CTX.fill();
            }
            checkAnnotations() {
                // Check if the distance of every annotation is at least ABSTRACTIONSMAXIMUMDISTANCE to one of the others
                // if not, remove the annotation from the abstraction
                for (let x = 0; x < this.annotations.length; x++) {
                    let oneCloseAnnotation = false;
                    for (let y = 0; y < this.annotations.length; y++) {
                        if (x == y) continue;
                        let annotation1 = this.annotations[x];
                        let annotation2 = this.annotations[y];
                        // Check if the distance between the two annotations is below the minimum distance
                        let distance = Math.sqrt(
                            Math.pow(annotation1.positionX - annotation2.positionX, 2) +
                            Math.pow(annotation1.positionY - annotation2.positionY, 2)
                        );
                        if (distance < ABSTRACTIONSMAXIMUMDISTANCE) {
                            oneCloseAnnotation = true;
                        }
                    }
                    if (!oneCloseAnnotation) {
                        // If we reach this point, it means the annotation is too far from all others
                        this.annotations[x].abstraction = null;
                        // Remove the annotation from the abstraction
                        this.removeElement(this.annotations[x]);
                        this.updateTextElementPosition();
                        encodeStateAsURLHash();
                    }
                }
                if (this.annotations.length < 2) {
                    this.annotations.forEach((annotation) => {
                        // Remove the abstraction from the annotation
                        annotation.abstraction = null;
                    });
                    // Remove the abstraction from the global list
                    ABSTRACTIONS.splice(ABSTRACTIONS.indexOf(this), 1);
                    this.element.remove();
                    this.element = null;
                    encodeStateAsURLHash();
                    delete this;
                    return false;
                }
                return true;
            }
            encodeAsURLHash() {
                // Encode the abstraction as a string for the URL hash
                return `${this.text.replaceAll(' ', '_')}(${this.annotations.map((annotation) => annotation.encodeAsURLHash()).join(',')})`;
            }
        }
        function updateConnectionsWrapperSize() {
            CONNECTIONSWRAPPER.width = window.innerWidth;
            CONNECTIONSWRAPPER.height = window.innerHeight;
        }
        function showRelatedWordStems(word) {
            if (iFRAME) return;
            TEXTWRAPPER.querySelectorAll('.' + word).forEach((el) => {
                el.classList.add('hovered');
            });
        }
        function hideRelatedWordStems() {
            if (iFRAME) return;
            TEXTWRAPPER.querySelectorAll('.hovered').forEach((el) => {
                el.classList.remove('hovered');
            });
        }
        function encodeStateAsURLHash() {
            if (resetPage) return;
            blockHashChangeEvent = true;
            console.log('Setting URL hash');
            // Set the URL hash to the current annotations
            let annotationHash = ANNOTATIONS.map((annotation) => {
                if (annotation.abstraction) return null;
                return annotation.encodeAsURLHash();
            }).filter((item) => item !== null)
            let abstractionHash = ABSTRACTIONS.map((abstraction) => {
                return abstraction.encodeAsURLHash();
            })
            let joinedHash = [...abstractionHash, ...annotationHash].join(';');
            window.location.hash = `${textHash}&annotations=${joinedHash}`;
            window.setTimeout(() => { blockHashChangeEvent = false }, 100);
        }
        function decodeStateFromURLHash() {
            resetPage = true;
            // Reset the state from the URL hash
            let hash = decodeURI(window.location.hash.slice(1));
            if (hash) {
                let parts = hash.split('&').slice(1);
                if (parts.length >= 1 && parts[0].startsWith('annotations=')) {
                    let annotationsAndAbstractions = parts[0].slice(12).split(';');
                    if (annotationsAndAbstractions[0] === '') {
                        resetPage = false;
                        return;
                    }
                    annotationsAndAbstractions.map((annotationOrAbstraction) => {
                        if (RegExp(/\([!a-zA-Z]/g).test(annotationOrAbstraction)) {
                            let abstraction = annotationOrAbstraction.match(/(!?\w+[äöüß]?)/g)
                            let abstractionName = abstraction[0].replaceAll('_', ' ');
                            let newAbstraction = new Abstraction(abstractionName);
                            abstraction = abstraction.slice(1)
                            let annotations = [];
                            for (let i = 0; i < abstraction.length; i += 3) {
                                annotations.push([abstraction[i], abstraction[i + 1], abstraction[i + 2]]);
                            }
                            annotations.forEach((annotation) => {
                                if (annotation[0][0] == '!') {
                                    annotation[0] = annotation[0].slice(1);
                                    window.setTimeout(() => {
                                        TEXTWRAPPER.querySelector('#' + annotation[0]).scrollIntoView({
                                            block: 'center',
                                            behavior: 'smooth'
                                        });
                                    }, 100);
                                }
                                let referenceElement = TEXTWRAPPER.querySelector('#' + annotation[0]);
                                if (referenceElement && ANNOTATIONS.findIndex((el) => el.reference === annotation[0]) === -1) {
                                    console.log('Creating annotation for abstraction', annotation[0], referenceElement.innerText);
                                    let annotationInstance = new Annotation(referenceElement.innerText, annotation[0], parseInt(annotation[1]), parseInt(annotation[2]));
                                    annotationInstance.abstraction = newAbstraction;
                                    newAbstraction.addElement(annotationInstance);
                                }
                            });
                            ABSTRACTIONS.push(newAbstraction);
                            newAbstraction.updateTextElementPosition();
                            //if true => abstraction
                        } else {
                            let annotation = annotationOrAbstraction.match(/(!?\w+[äöüß]?)/g)
                            console.log('Creating annotation from URL hash', annotation);
                            if (annotation[0][0] == '!') {
                                annotation[0] = annotation[0].slice(1);
                                window.setTimeout(() => {
                                    TEXTWRAPPER.querySelector('#' + annotation[0]).scrollIntoView({
                                        block: 'center',
                                        behavior: 'smooth'
                                    });
                                }, 100);
                            }
                            let referenceElement = TEXTWRAPPER.querySelector('#' + annotation[0]);
                            if (referenceElement) {
                                new Annotation(referenceElement.innerText, annotation[0], parseInt(annotation[1]), parseInt(annotation[2]));
                            }
                        }
                    })
                }
            }
            console.log('Annotations and Abstractions loaded from URL hash', ANNOTATIONS, ABSTRACTIONS);
            resetPage = false;
        }
        function resetState() {
            stopLoop = true;
            // Remove all annotations and abstractions from the DOM
            ANNOTATIONS.forEach((annotation) => {
                if (annotation.element) {
                    annotation.element.remove();
                }
                if (annotation.abstraction && annotation.abstraction.textElement) {
                    annotation.abstraction.textElement.remove();
                    annotation.abstraction.textElement = null;
                }
                annotation.stems.forEach((stemInstance) => {
                    stemInstance.classList.remove('extracted');
                    stemInstance.style.backgroundColor = '';
                    stemInstance.style.color = '';
                });
                let referenceElement = TEXTWRAPPER.querySelector('#' + annotation.reference);
                if (referenceElement) {
                    referenceElement.classList.remove('extracted');
                    referenceElement.style.backgroundColor = '';
                    referenceElement.style.color = '';
                }
            });
            ABSTRACTIONS.forEach((abstraction) => {
                if (abstraction.element) {
                    abstraction.element.remove();
                }
            });
            // Reset all global variables
            ANNOTATIONS = [];
            ABSTRACTIONS = [];
            colorCounter = 0;
            stopLoop = false;
            annotationsMovement = false;
            annotationsMovementObject = null
            annotationsMovementOffsetX = 0;
            annotationsMovementOffsetY = 0;
        }
        async function loop() {
            if (stopLoop) return
            // Clear the canvas and redraw all connections and hull
            CTX.clearRect(0, 0, CONNECTIONSWRAPPER.width, CONNECTIONSWRAPPER.height);
            ANNOTATIONS.forEach((annotation) => {
                annotation.renderConnections();
            });
            ABSTRACTIONS.forEach((abstraction) => {
                abstraction.renderHull();
            });
            requestAnimationFrame(loop);
        }
        window.addEventListener('mousemove', (e) => {
            if (annotationsMovement) {
                let newLeft = e.clientX - annotationsMovementOffsetX;
                let newTop = e.clientY - annotationsMovementOffsetY;
                annotationsMovementObject.updatePosition(newLeft, newTop);
            }
        });
        window.addEventListener('mouseup', (e) => {
            if (annotationsMovement) {
                annotationsMovement = false;
                annotationsMovementObject = null;
                encodeStateAsURLHash();
            }
        });
        window.addEventListener('resize', (e) => {
            updateConnectionsWrapperSize();
        });
        window.addEventListener('hashchange', (e) => {
            e.preventDefault();
            // Reset the application state when the hash changes
            //if (!iFRAME || resetPage) return;
            if (blockHashChangeEvent) return;
            console.log('Hash changed, resetting application state');
            resetState();
            decodeStateFromURLHash();
            updateConnectionsWrapperSize();
            loop();
        });
        TEXTWRAPPER.addEventListener('scroll', (e) => {
            // Prevent scrolling of the body
            // annotationLineOpacity = 0.8;
            // console.log('scrolling');
            // let reduceOpacity = setInterval(() => {
            //     annotationLineOpacity -= 0.0005;
            //     if (annotationLineOpacity <= 0.05) {
            //         annotationLineOpacity = 0.05;
            //         clearInterval(reduceOpacity);
            //     }
            // }, 50);
        });
        // Get request text from server and parse it via marked.js
        textHash = window.location.hash.slice(1).match(/\w+/)[0];
        fetch(`/${local ? '' : 'textarium/'}${textHash}.md`)
        .then(response => response.text())
        .then(text => {
            if (!text) {
                console.error('No text found for the given hash:', textHash);
                return;
            }
            let parsedText = text
                .replaceAll('\n', ' \n ')
                .split(' ')
                .map((word, index) => {
                if (word != '#' && !RegExp(/[<>\d|-]/).test(word)) {
                    let sanitizedWord = word.replace(/[^a-zA-Z]/g, '');
                    let stemmedWord = stemmer(sanitizedWord).toLocaleLowerCase();
                    word = word.replace(
                        /(\w+)/g,
                        `<span id="${sanitizedWord + index}" onclick="Annotation.createAnnotation('${sanitizedWord}', '${sanitizedWord + index}')" onmouseleave="hideRelatedWordStems()" onmouseenter="showRelatedWordStems('${stemmedWord}')" class='word ${stemmedWord}'>${sanitizedWord}</span>`
                    );
                }
                return word;
            })
            .join(' ');
            TEXTWRAPPER.innerHTML = marked.parse(parsedText);
        }).then(() => {
            decodeStateFromURLHash();
            updateConnectionsWrapperSize();
            loop();
        })
    </script>
</body>

</html>